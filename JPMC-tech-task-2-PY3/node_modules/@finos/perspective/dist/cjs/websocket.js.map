{"version":3,"sources":["../../src/js/websocket.js"],"names":["HEARTBEAT_TIMEOUT","CLIENT_ID_GEN","constructor","id","cmd","heartbeat","setTimeout","msg","result","data","new_data_with_port_id","port_id","delta","JSON","send","pre_msg","terminate","resolve","setInterval","Object","ws","add_connection","buffer","new_args","compoundId","console","post","req","transferable","_host","cache","name","input","host_table","host_view","eject_table","eject_view"],"mappings":"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","sourcesContent":["import {Client} from \"./api/client.js\";\nimport {Server} from \"./api/server.js\";\n\nconst HEARTBEAT_TIMEOUT = 15000;\nlet CLIENT_ID_GEN = 0;\n\nexport class WebSocketClient extends Client {\n    constructor(ws) {\n        super();\n        this._ws = ws;\n        this._ws.binaryType = \"arraybuffer\";\n        this._ws.onopen = () => {\n            this.send({id: -1, cmd: \"init\"});\n        };\n        const heartbeat = () => {\n            this._ws.send(\"heartbeat\");\n            setTimeout(heartbeat, HEARTBEAT_TIMEOUT);\n        };\n        setTimeout(heartbeat, 15000);\n        this._ws.onmessage = msg => {\n            if (msg.data === \"heartbeat\") {\n                return;\n            }\n            if (this._pending_arrow) {\n                let result = {\n                    data: {\n                        id: this._pending_arrow,\n                        data: msg.data\n                    }\n                };\n\n                // make sure on_update callbacks are called with a `port_id`\n                // AND the transferred arrow.\n                if (this._pending_port_id !== undefined) {\n                    const new_data_with_port_id = {\n                        port_id: this._pending_port_id,\n                        delta: msg.data\n                    };\n                    result.data.data = new_data_with_port_id;\n                }\n                this._handle(result);\n                delete this._pending_port_id;\n                delete this._pending_arrow;\n            } else {\n                msg = JSON.parse(msg.data);\n\n                // If the `is_transferable` flag is set, the worker expects the\n                // next message to be a transferable object. This sets the\n                // `_pending_arrow` flag, which triggers a special handler for\n                // the ArrayBuffer containing arrow data.\n                if (msg.is_transferable) {\n                    this._pending_arrow = msg.id;\n\n                    // Check whether the message also contains a `port_id`,\n                    // indicating that we are in an `on_update` callback and\n                    // the pending arrow needs to be joined with the port_id\n                    // for on_update handlers to work properly.\n                    if (msg.data && msg.data.port_id !== undefined) {\n                        this._pending_port_id = msg.data.port_id;\n                    }\n                } else {\n                    this._handle({data: msg});\n                }\n            }\n        };\n    }\n\n    /**\n     * Send a message to the remote, checking whether the arguments contain an\n     * ArrayBuffer.\n     *\n     * @param {Object} msg a message to send to the remote. If the `args`\n     * param contains an ArrayBuffer, two messages will be sent - a pre-message\n     * with the `is_transferable` flag set to true, and a second message\n     * containing the ArrayBuffer. This allows for transport of metadata\n     * alongside an ArrayBuffer, and the pattern should be implemented by the\n     * receiver.\n     */\n    send(msg) {\n        if (msg.args && msg.args.length > 0 && msg.args[0] instanceof ArrayBuffer && msg.args[0].byteLength !== undefined) {\n            const pre_msg = msg;\n            msg.is_transferable = true;\n            this._ws.send(JSON.stringify(pre_msg));\n            this._ws.send(msg.args[0]);\n            return;\n        }\n        this._ws.send(JSON.stringify(msg));\n    }\n\n    terminate() {\n        return new Promise(resolve => {\n            this._ws.onclose = resolve;\n            this._ws.close();\n        });\n    }\n}\n\n/**\n * A WebSocket Manager instance for a remote perspective\n */\nexport class WebSocketManager extends Server {\n    constructor(...args) {\n        super(...args);\n        this.requests_id_map = new Map();\n        this.requests = {};\n        this.websockets = {};\n\n        // clear invalid connections\n        setInterval(() => {\n            Object.entries(this.websockets).forEach(([id, ws]) => {\n                if (ws.isAlive === false) {\n                    delete this.websockets[id];\n                    return ws.terminate();\n                }\n                ws.isAlive = false;\n            });\n        }, 30000);\n    }\n\n    /**\n     * Add a new websocket connection to the manager, and define a handler\n     * for all incoming messages. If the incoming message has `is_transferable`\n     * set, handle incoming `ArrayBuffers` correctly.\n     *\n     * The WebsocketManager manages the websocket connection and processes every\n     * message received from each connections. When a websocket connection is\n     * `closed`, the websocket manager will clear all subscriptions associated\n     * with the connection.\n     *\n     * @param {WebSocket} ws a websocket connection\n     */\n    add_connection(ws) {\n        ws.isAlive = true;\n        ws.binaryType = \"arraybuffer\";\n        ws.id = CLIENT_ID_GEN++;\n\n        // Parse incoming messages\n        ws.on(\"message\", msg => {\n            ws.isAlive = true;\n\n            if (msg === \"heartbeat\") {\n                ws.send(\"heartbeat\");\n                return;\n            }\n\n            if (this._is_transferable) {\n                // Combine ArrayBuffer and previous message so that metadata can\n                // be reconstituted.\n                const buffer = msg;\n                let new_args = [buffer];\n                msg = this._is_transferable_pre_message;\n\n                if (msg.args && msg.args.length > 1) {\n                    new_args = new_args.concat(msg.args.slice(1));\n                }\n\n                msg.args = new_args;\n                delete msg.is_transferable;\n\n                this._is_transferable = false;\n                this._is_transferable_pre_message = undefined;\n            } else {\n                msg = JSON.parse(msg);\n\n                if (msg.is_transferable) {\n                    this._is_transferable = true;\n                    this._is_transferable_pre_message = msg;\n                    return;\n                }\n            }\n\n            try {\n                // Send all messages to the handler defined in\n                // Perspective.Server\n                const compoundId = `${msg.id}/${ws.id}`;\n                this.requests_id_map.set(compoundId, msg.id);\n                msg.id = compoundId;\n                this.requests[msg.id] = {ws, msg};\n                this.process(msg, ws.id);\n            } catch (e) {\n                console.error(e);\n            }\n        });\n        ws.on(\"close\", () => {\n            this.clear_views(ws.id);\n        });\n        ws.on(\"error\", console.error);\n    }\n\n    /**\n     * Send an asynchronous message to the Perspective web worker.\n     *\n     * If the `transferable` param is set, pass two messages: the string\n     * representation of the message and then the ArrayBuffer data that needs to\n     * be transferred. The `is_transferable` flag tells the client to expect the\n     * next message to be a transferable object.\n     *\n     * @param {Object} msg a valid JSON-serializable message to pass to the\n     * client\n     * @param {*} transferable a transferable object to be sent to the client\n     */\n    post(msg, transferable) {\n        const req = this.requests[msg.id];\n        const id = msg.id;\n        if (req.ws.readyState > 1) {\n            delete this.requests[id];\n            throw new Error(\"Connection closed\");\n        }\n        msg.id = this.requests_id_map.get(id);\n        if (transferable) {\n            msg.is_transferable = true;\n            req.ws.send(JSON.stringify(msg));\n            req.ws.send(transferable[0]);\n        } else {\n            req.ws.send(JSON.stringify(msg));\n        }\n        if (!req.msg.subscribe) {\n            this.requests_id_map.delete(id);\n            delete this.requests[id];\n        }\n    }\n\n    _host(cache, name, input) {\n        if (cache[name] !== undefined) {\n            throw new Error(`\"${name}\" already exists`);\n        }\n        input.on_delete(() => {\n            delete cache[name];\n        });\n        cache[name] = input;\n    }\n\n    /**\n     * Expose a Perspective `table` through the WebSocket, allowing\n     * it to be accessed by a unique name from a client.  Hosted objects\n     * are automatically `eject`ed when their `delete()` method is called.\n     *\n     * @param {String} name\n     * @param {perspective.table} table `table` to host.\n     */\n    host_table(name, table) {\n        this._host(this._tables, name, table);\n    }\n\n    /**\n     * Expose a Perspective `view` through the WebSocket, allowing\n     * it to be accessed by a unique name from a client.  Hosted objects\n     * are automatically `eject`ed when their `delete()` method is called.\n     *\n     * @param {String} name\n     * @param {perspective.view} view `view` to host.\n     */\n    host_view(name, view) {\n        this._host(this._views, name, view);\n    }\n\n    /**\n     * Cease hosting a `table` on this server.  Hosted objects\n     * are automatically `eject`ed when their `delete()` method is called.\n     *\n     * @param {String} name\n     */\n    eject_table(name) {\n        delete this._tables[name];\n    }\n\n    /**\n     * Cease hosting a `view` on this server.  Hosted objects\n     * are automatically `eject`ed when their `delete()` method is called.\n     *\n     * @param {String} name\n     */\n    eject_view(name) {\n        delete this._views[name];\n    }\n}\n"],"file":"websocket.js"}